package exchange

import (
	"errors"
	"reflect"
	"strconv"

	"github.com/Beldur/kraken-go-api-client"
	"github.com/lightyeario/kelp/support/exchange/assets"
	"github.com/lightyeario/kelp/support/exchange/dates"
	"github.com/lightyeario/kelp/support/exchange/number"
	"github.com/lightyeario/kelp/support/exchange/orderbook"
	"github.com/lightyeario/kelp/support/exchange/trades"
)

// ensure that krakenExchange conforms to the Exchange interface
var _ Exchange = krakenExchange{}

// krakenExchange is the implementation for the Kraken Exchange
type krakenExchange struct {
	assetConverter *assets.AssetConverter
	api            *krakenapi.KrakenApi
	delimiter      string
}

// Values gives you the values of a map
// TODO 2 - move to autogenerated generic function
func Values(m map[assets.TradingPair]string) []string {
	values := []string{}
	for _, v := range m {
		values = append(values, v)
	}
	return values
}

// GetTickerPrice impl.
func (k krakenExchange) GetTickerPrice(pairs []assets.TradingPair) (map[assets.TradingPair]Ticker, error) {
	pairsMap, e := assets.TradingPairs2Strings(k.assetConverter, k.delimiter, pairs)
	if e != nil {
		return nil, e
	}

	resp, e := k.api.Ticker(Values(pairsMap)...)
	if e != nil {
		return nil, e
	}

	priceResult := map[assets.TradingPair]Ticker{}
	for _, p := range pairs {
		pairTickerInfo := resp.GetPairTickerInfo(pairsMap[p])
		priceResult[p] = Ticker{
			AskPrice:  number.MustFromString(pairTickerInfo.Ask[0]),
			AskVolume: number.MustFromString(pairTickerInfo.Ask[1]),
			BidPrice:  number.MustFromString(pairTickerInfo.Bid[0]),
			BidVolume: number.MustFromString(pairTickerInfo.Bid[1]),
		}
	}

	return priceResult, nil
}

// GetAccountBalances impl.
func (k krakenExchange) GetAccountBalances(assetList []assets.Asset) (map[assets.Asset]number.Number, error) {
	balanceResponse, e := k.api.Balance()
	if e != nil {
		return nil, e
	}

	m := map[assets.Asset]number.Number{}
	for _, a := range assetList {
		krakenAssetString, e := k.assetConverter.ToString(a)
		if e != nil {
			// discard partially built map for now
			return nil, e
		}
		bal := getFieldValue(*balanceResponse, krakenAssetString)
		m[a] = *number.FromFloat(float64(bal))
	}
	return m, nil
}

// GetOrderBook impl.
func (k krakenExchange) GetOrderBook(pair assets.TradingPair, maxCount int32) (*orderbook.OrderBook, error) {
	pairStr, e := pair.ToString(k.assetConverter, k.delimiter)
	if e != nil {
		return nil, e
	}
	krakenob, e := k.api.Depth(pairStr, int(maxCount))
	if e != nil {
		return nil, e
	}

	asks := readOrders(krakenob.Asks, orderbook.TypeAsk)
	bids := readOrders(krakenob.Bids, orderbook.TypeBid)
	ob := orderbook.MakeOrderBook(asks, bids)
	return ob, nil
}

// GetTrades impl.
func (k krakenExchange) GetTrades(pair assets.TradingPair, maybeCursor interface{}) (*TradesResult, error) {
	if maybeCursor != nil {
		mc := maybeCursor.(int64)
		return k.getTrades(pair, &mc)
	}
	return k.getTrades(pair, nil)
}

func (k krakenExchange) getTrades(pair assets.TradingPair, maybeCursor *int64) (*TradesResult, error) {
	pairStr, e := pair.ToString(k.assetConverter, k.delimiter)
	if e != nil {
		return nil, e
	}

	var tradesResp *krakenapi.TradesResponse
	if maybeCursor != nil {
		tradesResp, e = k.api.Trades(pairStr, *maybeCursor)
	} else {
		tradesResp, e = k.api.Trades(pairStr, -1)
	}
	if e != nil {
		return nil, e
	}

	tradesResult := &TradesResult{
		Cursor: tradesResp.Last,
		Trades: []trades.Trade{},
	}
	for _, tInfo := range tradesResp.Trades {
		tradeType, e := getTradeType(tInfo)
		if e != nil {
			return nil, e
		}
		tradesResult.Trades = append(tradesResult.Trades, trades.Trade{
			Type:      tradeType,
			Price:     number.FromFloat(tInfo.PriceFloat),
			Volume:    number.FromFloat(tInfo.VolumeFloat),
			Timestamp: dates.MakeTimestamp(tInfo.Time),
		})
	}
	return tradesResult, nil
}

// GetTradeHistory impl.
func (k krakenExchange) GetTradeHistory(maybeCursorStart interface{}, maybeCursorEnd interface{}) (*TradeHistoryResult, error) {
	var mcs *int64
	if maybeCursorStart != nil {
		i := maybeCursorStart.(int64)
		mcs = &i
	}

	var mce *int64
	if maybeCursorEnd != nil {
		i := maybeCursorEnd.(int64)
		mce = &i
	}

	return k.getTradeHistory(mcs, mce)
}

func (k krakenExchange) getTradeHistory(maybeCursorStart *int64, maybeCursorEnd *int64) (*TradeHistoryResult, error) {
	input := map[string]string{}
	if maybeCursorStart != nil {
		input["start"] = strconv.FormatInt(*maybeCursorStart, 10)
	}
	if maybeCursorEnd != nil {
		input["end"] = strconv.FormatInt(*maybeCursorEnd, 10)
	}

	resp, e := k.api.Query("TradesHistory", input)
	if e != nil {
		return nil, e
	}
	krakenResp := resp.(map[string]interface{})
	krakenTrades := krakenResp["trades"].(map[string]interface{})

	res := TradeHistoryResult{Trades: []trades.Trade{}}
	for _, v := range krakenTrades {
		m := v.(map[string]interface{})
		_txid := m["ordertxid"].(string)
		_time := m["time"].(float64)
		ts := dates.MakeTimestamp(int64(_time))
		_type := m["type"].(string)
		_ordertype := m["ordertype"].(string)
		tradeType, e := getTradeTypeFromStrings(_type, _ordertype)
		if e != nil {
			return nil, e
		}
		_price := m["price"].(string)
		_vol := m["vol"].(string)
		_cost := m["cost"].(string)
		_fee := m["fee"].(string)
		_pair := m["pair"].(string)
		pair, e := k.parsePair(_pair)
		if e != nil {
			return nil, e
		}

		res.Trades = append(res.Trades, trades.Trade{
			TransactionID: &_txid,
			Timestamp:     ts,
			// TODO 2 - make clear what is base and what is quote currency -- base is AssetA, quote is AssetB?
			Pair:   pair,
			Type:   tradeType,
			Price:  number.MustFromString(_price),
			Volume: number.MustFromString(_vol),
			Cost:   number.MustFromString(_cost),
			Fee:    number.MustFromString(_fee),
		})
	}
	return &res, nil
}

// save this map for now to avoid if branches in GetOpenOrders below
var orderTypeMap = map[string]orderbook.OrderType{
	"buy":  orderbook.TypeBid,
	"sell": orderbook.TypeAsk,
}

// GetOpenOrders impl.
func (k krakenExchange) GetOpenOrders() (map[assets.TradingPair][]orderbook.OpenOrder, error) {
	openOrdersResponse, e := k.api.OpenOrders(map[string]string{})
	if e != nil {
		return nil, e
	}

	// TODO 2 - not sure if the trading pair is ordered correctly with the orderTypeMap above for buy/sell
	m := map[assets.TradingPair][]orderbook.OpenOrder{}
	for _, o := range openOrdersResponse.Open {
		pair, e := k.parsePair(o.Description.AssetPair)
		if e != nil {
			return nil, e
		}
		if _, ok := m[*pair]; !ok {
			m[*pair] = []orderbook.OpenOrder{}
		}

		m[*pair] = append(m[*pair], orderbook.OpenOrder{
			Order: orderbook.Order{
				OrderType: orderTypeMap[o.Description.Type],
				Price:     number.FromFloat(o.Price),
				Volume:    number.MustFromString(o.Volume),
				Timestamp: dates.MakeTimestamp(int64(o.OpenTime)),
			},
			ID:             o.ReferenceID, // TODO 2 - is this correct, or should it be o.UserRef?
			StartTime:      dates.MakeTimestamp(int64(o.StartTime)),
			ExpireTime:     dates.MakeTimestamp(int64(o.ExpireTime)),
			VolumeExecuted: number.FromFloat(o.VolumeExecuted),
		})
	}
	return m, nil
}

func (k krakenExchange) parsePair(p string) (*assets.TradingPair, error) {
	a, e := k.assetConverter.FromString(p[0:4])
	if e != nil {
		return nil, e
	}

	b, e := k.assetConverter.FromString(p[4:8])
	if e != nil {
		return nil, e
	}

	return &assets.TradingPair{AssetA: a, AssetB: b}, nil
}

func getTradeType(tInfo krakenapi.TradeInfo) (*trades.TradeType, error) {
	var tradeType *trades.TradeType
	if tInfo.Buy {
		if tInfo.Market {
			tradeType = trades.BuyMarket
		} else if tInfo.Limit {
			tradeType = trades.BuyLimit
		} else {
			return nil, errors.New("unidentified buy trade type")
		}
	} else if tInfo.Sell {
		if tInfo.Market {
			tradeType = trades.SellMarket
		} else if tInfo.Limit {
			tradeType = trades.SellLimit
		} else {
			return nil, errors.New("unidentified sell trade type")
		}
	} else {
		return nil, errors.New("unidentified trade type")
	}
	return tradeType, nil
}

func getTradeTypeFromStrings(_type string, _ordertype string) (*trades.TradeType, error) {
	var tradeType *trades.TradeType
	if _type == "buy" {
		if _ordertype == "market" {
			tradeType = trades.BuyMarket
		} else if _ordertype == "limit" {
			tradeType = trades.BuyLimit
		} else {
			return nil, errors.New("unidentified buy trade type")
		}
	} else if _type == "sell" {
		if _ordertype == "market" {
			tradeType = trades.SellMarket
		} else if _ordertype == "limit" {
			tradeType = trades.SellLimit
		} else {
			return nil, errors.New("unidentified sell trade type")
		}
	} else {
		return nil, errors.New("unidentified trade type")
	}
	return tradeType, nil
}

func readOrders(obi []krakenapi.OrderBookItem, orderType orderbook.OrderType) []orderbook.Order {
	orders := []orderbook.Order{}
	for _, item := range obi {
		orders = append(orders, orderbook.Order{
			OrderType: orderType,
			Price:     number.FromFloat(item.Price),
			Volume:    number.FromFloat(item.Amount),
			Timestamp: dates.MakeTimestamp(item.Ts),
		})
	}
	return orders
}

func getFieldValue(object krakenapi.BalanceResponse, fieldName string) float32 {
	r := reflect.ValueOf(object)
	f := reflect.Indirect(r).FieldByName(fieldName)
	return f.Interface().(float32)
}
